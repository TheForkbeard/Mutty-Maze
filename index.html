<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>Mutty Maze</title>
</head>
<body>
    <header>
        <h1>Mutty Maze</h1>
    </header>
    <canvas width="192" height="192" ></canvas>
        
    <div class="controls">
        <div>
        <button class="direction" id="up">UP</button>
        </div>
        <div>
        <button class="direction" id="left">LEFT</button>
        <button class="direction" id="right">RIGHT</button>
        </div>
        <div>
        <button class="direction" id="down">DOWN</button>
        </div>
    </div>

    <script>

        (function() {
            // canvas variables
            let canvas = document.querySelector("canvas");
            let drawingSurface = canvas.getContext("2d");

            // game map variable
            let map = [
                [2, 2, 2, 2, 2, 2, 2],
                [2, 1, 1, 1, 2, 1, 2],
                [2, 1, 2, 1, 2, 1, 2],
                [2, 1, 2, 1, 1, 1, 2],
                [2, 1, 2, 2, 2, 1, 2],
                [2, 1, 1, 1, 2, 1, 2],
                [2, 2, 2, 2, 2, 2, 2]
            ];

            // game object variable
            let gameObjects = [
                [0, 0, 0, 0, 0, 0, 0],
                [0, 3, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0]
            ];

            //map codes
            const EMPTY = 0;
            const FLOOR  = 1;
            const WALL = 2;
            const MUTTY = 3;

            // the size of each tile cell, this is what I need to be able to adapt make this work
            const SIZE = 64;
            // lets see if that works?



            let mutty = null;

            // forgot to include the sprite objects
            let spriteObject = {
            sourceX: 0,
            sourceY: 0,
            sourceWidth: 64,
            sourceHeight: 64,
            x: 0,
            y: 0,
            height: 64,
            width: 64,
            };

            const ROWS = map.length;
            const COLUMNS = map[0].length;

            // the number of columns on the tilesheet,  not sure about how this works yet but will observe
            let tilesheetColumns = 3;

            // the arrays for the game objects
            let sprites = [];
            let walls = [];

            // now to start the rendering proccess 
            let assetsToLoad = [];
            let assetsLoaded = 0;

            // load the tilesheet image
            let image = new Image();
            image.addEventListener("load", loadHandler, false);
            image.src = "assets/images/mutty-tile-2.png";
            assetsToLoad.push(image);

            // to test the rendering I will contstruct basic loadHandler, buildMap and render functions.
            // This did not work so I am adapting the update from the book to the update function.
            
            //Game states
            const LOADING = 0;
            const BUILD_MAP = 1;
            const PLAYING = 2;
            //const OVER = 3;
            let gameState = LOADING;

            //--- The gameWorld object
            let gameWorld = {
                x: 0,
                y: 0,
                width: map[0].length * SIZE,
                height: map.length * SIZE,
            };

            //--- The camera object
            let camera = {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height,
  
                //The camera's inner scroll boundaries
                rightInnerBoundary: function(){
                    return this.x + (this.width / 1) + (this.width / 2);
                },
                leftInnerBoundary: function(){
                    return this.x + (this.width / 1) - (this.width / 2);
                },
                topInnerBoundary: function(){
                    return this.y + (this.height / 1) - (this.height / 2);
                },
                bottomInnerBoundary: function(){
                    return this.y + (this.height / 1) + (this.height / 2);
                }
            };

            //Center the camera over the gameWorld
            camera.x = (gameWorld.x + gameWorld.width / 2) - camera.width / 2;
            camera.y = (gameWorld.y + gameWorld.height / 2) - camera.height / 2;

            //Arrow key codes
            var UP = 38;
            var DOWN = 40;
            var RIGHT = 39;
            var LEFT = 37;

            //Directions
            var moveUp = false;
            var moveDown = false;
            var moveRight = false;
            var moveLeft = false;

            //Add keyboard listeners
            window.addEventListener("keydown", function(event){
                switch(event.keyCode){
                    case UP:
	                    moveUp = true;
	                    break;
	  
	                case DOWN:
	                    moveDown = true;
	                    break;
	    
	                case LEFT:
	                    moveLeft = true;
	                    break;  
	    
	                case RIGHT:
	                    moveRight = true;
	                    break; 
                }
            }, false);

            window.addEventListener("keyup", function(event){
                switch(event.keyCode){
                    case UP:
	                    moveUp = false;
	                    break;
	  
	                case DOWN:
	                    moveDown = false;
	                    break;
	    
	                case LEFT:
	                    moveLeft = false;
	                    break;  
	    
	                case RIGHT:
	                    moveRight = false;
	                    break; 
                }
            }, false);


            //Start the game animation loop
            update();

            function update()
            { 
                //The animation loop
                //setTimeout(update, 16);
                requestAnimationFrame(update, canvas);

                //Change what the game is doing based on the game state
                    switch(gameState)
                        {
                            case LOADING:
                                console.log("loading...");
                                break;
      
                            case BUILD_MAP:
                                buildMap(map);
                                buildMap(gameObjects);
                                //createOtherObjects();
                                gameState = PLAYING;
                                break;
    
                            case PLAYING:
                                playGame();
                                break;
    /*
                            case OVER:
                                endGame();
                                break;*/
                        }

                // and call the render function
                render();  
            }

            function loadHandler() {
                assetsLoaded++;
                if(assetsLoaded === assetsToLoad.length) {
                    // when assetsLoaded is finished remove the load handler
                    image.removeEventListener("load", loadHandler, false);

                    // this is to test if my idea will render calling the buildmap function twice to be able to render it
                    //that didn't works so back to basics
                    //Build the level 
                    gameState = BUILD_MAP;
                    

                                      
                }
            }

            // the buildMap function
            function buildMap(levelMap) {
                for(let row = 0; row < ROWS; row++) {
                    for(let column = 0; column < COLUMNS; column++) {
                        let currentTile = levelMap[row][column];
                        if(currentTile !== EMPTY) {
                            // find the tile's x and y position on the tile sheet
                            let tilesheetX = Math.floor((currentTile - 1) % tilesheetColumns) * SIZE;
                            let tilesheetY = Math.floor((currentTile - 1) / tilesheetColumns) * SIZE;

                            switch(currentTile) {
                                case FLOOR: 
                                    let floor = Object.create(spriteObject);
                                    floor.sourceX = tilesheetX;
                                    floor.sourceY = tilesheetY;
                                    floor.x = column * SIZE;
                                    floor.y = row * SIZE;
                                    sprites.push(floor);
                                    break;
                                
                                case WALL:
                                    let wall = Object.create(spriteObject);
                                    wall.sourceX = tilesheetX;
                                    wall.sourceY = tilesheetY;
                                    wall.x = column * SIZE;
                                    wall.y = row *  SIZE;
                                    sprites.push(wall);
                                    break;
                                
                                case MUTTY:
                                    mutty = Object.create(spriteObject);
                                    mutty.sourceX = tilesheetX;
                                    mutty.sourceY = tilesheetY;
                                    mutty.x = column * SIZE;
                                    mutty.y = row * SIZE;
                                    sprites.push(mutty);
                                    break;
                            }
                        }
                    }
                }
            }

            function playGame(){ 
                //Up
                if(moveUp && !moveDown){
                    mutty.vy = -4;
                }
                //Down
                if(moveDown && !moveUp){
                    mutty.vy = 4;
                }
                //Left
                if(moveLeft && !moveRight){
                    mutty.vx = -4;
                }
                //Right
                if(moveRight && !moveLeft){
                    mutty.vx = 4;
                }

                //Set the alien's velocity to zero if none of the keys are being pressed
                if(!moveUp && !moveDown){
                    mutty.vy = 0;
                }
                if(!moveLeft && !moveRight){
                    mutty.vx = 0;
                }
  
                //Move mutty and set its screen boundaries
                mutty.x = Math.max(64, Math.min(mutty.x + mutty.vx, gameWorld.width - mutty.width - 64)); 
                mutty.y = Math.max(64, Math.min(mutty.y + mutty.vy, gameWorld.height - mutty.height - 64));
                //Scroll the camera
                if(mutty.x < camera.leftInnerBoundary()){
                    camera.x = Math.floor(mutty.x - (camera.width / 2));
                }
                if(mutty.y < camera.topInnerBoundary()){
                    camera.y = Math.floor(mutty.y - (camera.height / 2));
                }
                if(mutty.x + mutty.width > camera.rightInnerBoundary()){
                    camera.x = Math.floor(mutty.x + mutty.width - (camera.width / 2 * 3));
                }
                if(mutty.y + mutty.height > camera.bottomInnerBoundary()){
                    camera.y = Math.floor(mutty.y + mutty.height - (camera.height / 2 * 3));
                }
  
                //The camera's gameWorld boundaries
                if(camera.x < gameWorld.x){
                    camera.x = gameWorld.x;
                }
                if(camera.y < gameWorld.y){
                    camera.y = gameWorld.y;
                }
                if(camera.x + camera.width > gameWorld.x + gameWorld.width){
                    camera.x = gameWorld.x + gameWorld.width - camera.width;
                }
                if(camera.y + camera.height > gameWorld.height){
                    camera.y = gameWorld.height - camera.height;
                } 
            }

            // thats the map built need to render it with a render function next
            function render(event) {
                drawingSurface.clearRect(0, 0, canvas.width, canvas.height);

                
                
                //Display the sprites
                    if(sprites.length !== 0)
                        {
                            for(let i = 0; i < sprites.length; i++)
	                            {
	                                let sprite = sprites[i];
                                            drawingSurface.drawImage(
                                                    image, 
                                                    sprite.sourceX,
                                                    sprite.sourceY, 
                                                    sprite.sourceWidth, 
                                                    sprite.sourceHeight,
                                                    Math.floor(sprite.x), 
                                                    Math.floor(sprite.y), 
                                                    sprite.width, 
                                                    sprite.height);
                                }
                        }
            }
        }());



    </script>
</body>
</html>